#!/usr/bin/env node

import { readFileSync, writeFileSync, existsSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const repoRoot = resolve(__dirname, "..");
const fluxPkgPath = resolve(repoRoot, "node_modules/@flux-lang/core/package.json");
const siblingFluxVersionPath = resolve(repoRoot, "../flux/version.json");
const publicVersionPath = resolve(repoRoot, "public/version.json");
const fluxMetaLibPath = resolve(repoRoot, "src/lib/fluxMeta.ts");
const fluxMetaConfigPath = resolve(repoRoot, "src/config/fluxMeta.ts");
const fluxRepoUrl = "https://github.com/cbassuarez/flux";

function normalizeVersion(version) {
  const raw = String(version ?? "").trim().replace(/^v+/i, "");
  return raw.length > 0 ? raw : "0.0.0";
}

function normalizeVersionPayload(input) {
  const payload = {
    version: normalizeVersion(input?.version),
  };

  if (input?.channel === "stable" || input?.channel === "canary") {
    payload.channel = input.channel;
  }
  if (typeof input?.build === "string" && input.build.trim().length > 0) {
    payload.build = input.build.trim();
  }
  if (typeof input?.sha === "string" && input.sha.trim().length > 0) {
    payload.sha = input.sha.trim();
  }

  return payload;
}

function readJson(path) {
  return JSON.parse(readFileSync(path, "utf8"));
}

function writeFluxMeta(version) {
  const tag = `v${version}`;
  const fluxRepoPermalink = `${fluxRepoUrl}/tree/${tag}`;

  const libContents = `// This file is generated by scripts/sync-flux-version.mjs
// Do not edit by hand.

export const fluxVersion = "${version}";
export const fluxRepoUrl = "${fluxRepoUrl}";
export const fluxRepoPermalink = "${fluxRepoPermalink}";
`;
  writeFileSync(fluxMetaLibPath, libContents);

  const configContents = `// This file is generated by scripts/sync-flux-version.mjs.
// Do not edit by hand.

export const FLUX_VERSION = "${version}";
export const FLUX_REPO_URL = "${fluxRepoUrl}";
export const FLUX_REPO_PERMALINK =
  "${fluxRepoPermalink}";
`;
  writeFileSync(fluxMetaConfigPath, configContents);
}

function main() {
  let source = "fallback";
  let versionPayload = { version: "0.0.0" };

  if (existsSync(siblingFluxVersionPath)) {
    try {
      versionPayload = normalizeVersionPayload(readJson(siblingFluxVersionPath));
      source = siblingFluxVersionPath;
    } catch (error) {
      console.warn(`[sync-flux-version] Failed to read ${siblingFluxVersionPath}: ${error}`);
    }
  } else if (existsSync(fluxPkgPath)) {
    try {
      const pkg = readJson(fluxPkgPath);
      versionPayload = normalizeVersionPayload({ version: pkg.version ?? "0.0.0" });
      source = fluxPkgPath;
    } catch (error) {
      console.warn(`[sync-flux-version] Failed to read ${fluxPkgPath}: ${error}`);
    }
  } else {
    console.warn(
      `[sync-flux-version] Could not find ${siblingFluxVersionPath} or ${fluxPkgPath}. ` +
      "Falling back to 0.0.0."
    );
  }

  const version = normalizeVersion(versionPayload.version);
  writeFileSync(publicVersionPath, `${JSON.stringify(versionPayload, null, 2)}\n`);
  writeFluxMeta(version);
  console.log(
    `[sync-flux-version] Synced ${publicVersionPath} and metadata to Flux version ${version} (source: ${source})`
  );
}

main();
